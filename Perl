#!C:\Perl64\bin\perl.exe

#Por ahora descarga los archivos del servidor, los descomprime (sobreescribiendo lo que saca).
#Tambien se conecta a la bbdd (local)
#Queda lograr automatizarlo
#Falta clasificarlo


use strict;
use warnings;
use strict;
use LWP::Simple;
use open qw( :encoding(latin1) :std ); # Make UTF-8 default encoding
use Archive::Zip qw( :ERROR_CODES :CONSTANTS );
use DBI;


#conocemos e imprimimos el dia corriente en cuestion
#esto servira para crear y eliminar los backup solicitados (con su respectivo nombre)
my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time);
$year += 1900;
$mon++;
print "$mday/$mon/$year $hour:$min:$sec\n";


#aqui se busca el nombre del archivo viejo si existiera
my $rootdir = 'C:\Users\Juan Nahuel Hidalgo\Desktop\Gral\paradigmas\2dotp\txt\infodiariac.txt';
unlink ($rootdir);


#aqui se almacena el archivo (no es necesario eliminar el viejo porque se sobreescribe)
my $urldiaria = 'https://ssl.smn.gob.ar/dpd/zipopendata.php?dato=tiepre';
my $archivodiario = 'diaria' . '.zip';
getstore( $urldiaria, $archivodiario );


#se extrae el archivo
my $zip = Archive::Zip->new($archivodiario);
my $destinationDirectory = 'C:\Users\Juan Nahuel Hidalgo\Desktop\Gral\paradigmas\2dotp\txt';
foreach my $member ($zip-> members)
{
    next if $member->isDirectory;
    (my $extractName = $member->fileName) =~ s{.*/}{};
    $member->extractToFileNamed(
      "$destinationDirectory/infodiaria.txt");   
}


my $url5dias = 'https://ssl.smn.gob.ar/dpd/zipopendata.php?dato=pron5d ';
my $cincodias = '5d' . '.zip';
getstore( $url5dias, $cincodias );
#aqui se almacena el archivo
my $zip2 = Archive::Zip->new($cincodias);
foreach my $member ($zip2-> members)
{
    next if $member->isDirectory;
    (my $extractName = $member->fileName) =~ s{.*/}{};
    $member->extractToFileNamed(
      "$destinationDirectory/cincodias.txt");
}
#se extrae el archivo

      
my $urldatosmet = 'https://ssl.smn.gob.ar/dpd/zipopendata.php?dato=datohorario';
my $historial = 'hist' . '.zip';
getstore( $urldatosmet, $historial );
#aqui se almacena el archivo
my $zip3 = Archive::Zip->new($historial);
foreach my $member ($zip3-> members)
{
    next if $member->isDirectory;
    (my $extractName = $member->fileName) =~ s{.*/}{};
    $member->extractToFileNamed(
      "$destinationDirectory/historial.txt");
}
#se extrae el archivo


#generamos nuestra base de datos con sus puertos, usuario, pw y nombre
 my $dbname1 = 'cincodias';
 my $dbname2 = 'historial';
 my $dbname3 = 'diario';
 my $dbhost = '127.0.0.1';
 my $dbuser = 'root';
 my $dbpwd = '';
 
#nos conectamos y la preparamos para agregar los datos
my $dbh1 = DBI->connect("DBI:mysql:database=$dbname1;host=$dbhost", $dbuser, $dbpwd, {RaiseError => 1});
my $sth1 = $dbh1->prepare(
         "INSERT INTO `cincodias`(`id`, `nombre`)
         VALUES (?,?)"
         );
my $dbh2 = DBI->connect("DBI:mysql:database=$dbname2;host=$dbhost", $dbuser, $dbpwd, {RaiseError => 1});
my $dbh3 = DBI->connect("DBI:mysql:database=$dbname3;host=$dbhost", $dbuser, $dbpwd, {RaiseError => 1});

#el siguiente comando introduce el valor a la bbdd en el orden de preparado
#$sth1->execute( 1, "hola");


  #Desconectar la base de datos
  if (! $dbh1->disconnect) {
     warn "Error al desconectarse de la base de datos: $DBI::errstr";
  }
  # Desconectar la base de datos
  if (! $dbh2->disconnect) {
     warn "Error al desconectarse de la base de datos: $DBI::errstr";
  }
  # Desconectar la base de datos
  if (! $dbh3->disconnect) {
     warn "Error al desconectarse de la base de datos: $DBI::errstr";
  }
