#!C:\Perl64\bin\perl.exe

#Por ahora descarga los archivos del servidor, los descomprime (sobreescribiendo lo que saca).
#Tambien se conecta a la bbdd (local) y coloca todos los registros diarios (hay que ver algunos caracteres con acentos)
#Se elimina todo lo innecesario del archivo 5dias, posteriormente escribiendo en otro lugar y borrando lo anterior (esto podria sobreescribirse igualando la ruta)
#Se traslada cada palabra del anterior archivo a un array. 
#Se esta clasificando 5dias.
#Mismo proceso para historial que para 5 dias.
#Se esta clasificando historial.
#Luego pueden subirse "facilmente" a la base de datos.
#Todo lo referente a 5dias es por fuerza bruta y usando algunas expresiones regulares, no muy lindo visualmente hablando.
#Queda lograr automatizarlo todo (maquina virtual?)



use strict;
use warnings;
use strict;
use LWP::Simple;
use open qw( :encoding(latin1) :std ); # Make UTF-8 default encoding
use Archive::Zip qw( :ERROR_CODES :CONSTANTS );
use DBI;
use Switch;

#conocemos e imprimimos el dia corriente en cuestion
#esto servira para crear y eliminar los backup solicitados (con su respectivo nombre)
my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time);
$year += 1900;
$mon++;
print "$mday/$mon/$year $hour:$min:$sec\n";


#aqui se busca el nombre del archivo viejo si existiera
my $rootdir = 'C:\Users\Juan Nahuel Hidalgo\Desktop\Gral\paradigmas\2dotp\txt\infodiariac.txt';
unlink ($rootdir);


#aqui se almacena el archivo (no es necesario eliminar el viejo porque se sobreescribe)
my $urldiaria = 'https://ssl.smn.gob.ar/dpd/zipopendata.php?dato=tiepre';
my $archivodiario = 'diaria' . '.zip';
getstore( $urldiaria, $archivodiario );


#se extrae el archivo
my $zip = Archive::Zip->new($archivodiario);
my $destinationDirectory = 'C:\Users\Juan Nahuel Hidalgo\Desktop\Gral\paradigmas\2dotp\txt';
foreach my $member ($zip-> members)
{
    next if $member->isDirectory;
    (my $extractName = $member->fileName) =~ s{.*/}{};
    $member->extractToFileNamed(
      "$destinationDirectory/infodiaria.txt");   
}


#generamos nuestra base de datos con sus puertos, usuario, pw y nombre
 my $dbname3 = 'diario';
 my $dbhost = '127.0.0.1';
 my $dbuser = 'root';
 my $dbpwd = '';
 #nos conectamos y la preparamos para agregar los datos
 my $dbh3 = DBI->connect("DBI:mysql:database=$dbname3;host=$dbhost", $dbuser, $dbpwd, {RaiseError => 1});
 
 my $sth3 = $dbh3->prepare(
         "INSERT INTO `diario2`(`nombre`, fecha, hora, tiempo, visibilidad, n1, n2, n3, direccion, n4)
         VALUES (?,?,?,?,?,?,?,?,?,?)"
         );
 

$dbh3 -> do ("truncate table diario2");

#si dropeamos la tabla en vez de truncarla lo de abajo tiene que estar.
#$dbh3 -> do("CREATE TABLE diario2 (nombre VARCHAR(30) PRIMARY KEY, fecha DATE, hora TIME, tiempo varchar(30), visibilidad int, n1 float, n2 float, n3 int, direccion varchar (30), n4 float)");


#abrimos y parseamos el archivo
open (FILE, 'C:\Users\Juan Nahuel Hidalgo\Desktop\Gral\paradigmas\2dotp\txt\infodiaria.txt') || die "Can't open this shit";; 
while (<FILE>) {
  chomp;

  
  #declaramos las variables que usaremos a la hora de parsear la informacion
  my $namediario;
  my $fechamal;
  my $horamal;
  my $tiempo,
  my $visibilidad;
  my $n1;
  my $n2;
  my $direccion;
  my $n3;
  my $n4;
  ($namediario, $fechamal, $horamal, $tiempo, $visibilidad, $n1, $n2, $n3, $direccion, $n4) = split(";");
   

 #puede ser sustituido por la linea del else todo el switch pero dejaria de ser parseo 100%
 my @fecha; 
 @fecha = split(/-/,$fechamal);
 switch($fecha[1]) {
    case ("enero")            { $fecha[1] = 1;}
    case ("febrero")          { $fecha[1] = 2; }
    case ("marzo")          {$fecha[1] = 3; }
    case ("abril")          { $fecha[1] = 4; }
    case ("mayo")          {$fecha[1] = 5; }
    case ("junio")          { $fecha[1] = 6; }
    case ("julio")          { $fecha[1] = 7; }
    case ("agosto")          { $fecha[1] = 8;  }
    case ("septiembre")          { $fecha[1] = 9; }
    case ("octubre")          { $fecha[1] = 10; }
    case ("noviembre")          { $fecha[1] = 11; }
    case ("diciembre")          { $fecha[1] = 12; }
    else              { $fecha[1] = $mon;  }
}
my $fechabien = "$fecha[2]/$fecha[1]/$fecha[0]";


#generamos una hora acorde a la bbdd
my @horas; 
@horas = split(/:/,$horamal);
my $horabien = "$horas[0]:$horas[1]:$horas[1]";


#el siguiente comando introduce el valor a la bbdd en el orden de preparado
$sth3->execute($namediario, $fechabien, $horabien, $tiempo, $visibilidad, $n1, $n2, $n3, $direccion, $n4);
}
 close (FILE);
#Desconectar la base de datos
$dbh3->disconnect();

   
my $url5dias = 'https://ssl.smn.gob.ar/dpd/zipopendata.php?dato=pron5d ';
my $cincodias = '5d' . '.zip';
getstore( $url5dias, $cincodias );
#aqui se almacena el archivo
my $zip2 = Archive::Zip->new($cincodias);
foreach my $member ($zip2-> members)
{
    next if $member->isDirectory;
    (my $extractName = $member->fileName) =~ s{.*/}{};
    $member->extractToFileNamed(
      "$destinationDirectory/cincodias.txt");
}
#se extrae el archivo

#generamos nuestra base de datos, sus puertos, usuario, pw y nombre ya fueron creados
my $dbname1 = 'cincodias';
#nos conectamos y la preparamos para agregar los datos
my $dbh1 = DBI->connect("DBI:mysql:database=$dbname1;host=$dbhost", $dbuser, $dbpwd, {RaiseError => 1});
my $sth1 = $dbh1->prepare(
         "INSERT INTO `cincodias`(`nombre`, `fecha`, `hora`, `temp`, `vientoDir`, `velViento`, `lluvia`)
         VALUES (?,?,?,?,?,?,?)"
         );
 
 #vamos a leer linea a linea el archivo original y el nuevo
 my $linea;
#abrimos y quitamos de en medio todo lo que no nos sirve del mismo escribiendo un nuevo archivo
open (OUT, '>C:\Users\Juan Nahuel Hidalgo\Desktop\Gral\paradigmas\2dotp\txt\cincodias2.txt') || die "Can't open this shit";
open (FILE, 'C:\Users\Juan Nahuel Hidalgo\Desktop\Gral\paradigmas\2dotp\txt\cincodias.txt') || die "Can't open this shit";
while ($linea= <FILE>) {
  chomp($linea);

#esto sustituve la barra media, el igual y el asterisco por un espacio vacio.
$linea =~ s/[|=*(),]//g;
#esto sustituye barra baja por un espacio.
$linea =~ s/[_]/ /g;



#quitamos distintas cosas molestas (esto puede ser mejorado pero no encontre la forma)
$linea =~ s/ Producto basado en un modelo de pronóstico numérico del tiempo//g;
$linea =~ s/ por lo tanto puede diferir del pronostico emitido por el SMN//g;
 $linea =~ s/      FECHA           TEMPERATURA      VIENTO      PRECIPITACIONmm//g;
  my $hola = "DIR  KM/H";
  $linea =~ s/$hola//g;
  my $hs = "Hs.";
  $linea =~ s/$hs//g;
 #$linea =~ s/ //g;
  print OUT $linea;
}
 close (FILE);
 close (OUT);

#aqui se busca el nombre del archivo viejo si existiera para eliminarlo
$rootdir = 'C:\Users\Juan Nahuel Hidalgo\Desktop\Gral\paradigmas\2dotp\txt\cincodias.txt';
unlink ($rootdir);

#Abrimos el archivo ya procesado para parsear
open (FILE, 'C:\Users\Juan Nahuel Hidalgo\Desktop\Gral\paradigmas\2dotp\txt\cincodias2.txt') || die "Can't open this shit";
while ($linea= <FILE>) {
  chomp($linea);
 #$linea =~ s/\n//g; 
 #llenaremos un array con cada conjunto de caracteres separados por un espacio
 my @palabras = split(/\s+/, $linea);
 
 #se elimina el primer espacio en blanco ya que eliminarlo por expresion regular es mas costoso a nivel de proceso.
shift(@palabras);
my @nombresa;

 
    for my $i (0 .. $#palabras)
{
      if (not ($palabras[ $i ] =~ /[0-9]/)) {
       $a = $i + 1;
       $b = $i - 1;
       my $aero = "AERO";
       my $de = "DE";
       if(($palabras[$a] =~ /$aero/)){
       $palabras[$i] = $palabras[$i] . " " . $palabras[$a];
       }
       if(($palabras[$i] =~ /$de/)){
       $palabras[$b] = $palabras[$b] . " " . $palabras[$i] . " " . $palabras[$a];
       }
      }
      print $palabras[$i], "\n"; #, ' is at location ' , $i , ' in the array' , "\n";
}
 
=a
 #si le digo que el lugar siguiente a ese lugar de array es un string le haga un join deberia juntar las cadenas
 #de nombres separados de los lugares
 for( my $Arrayindex = 0; $Arrayindex <= ( $#palabras ); $Arrayindex++)
 {
  if (not ($palabras[ $Arrayindex ] =~ /[1-9]/)) {

   
  if (($palabras[ $Arrayindex ] =~ /[a-zA-Z]/) && (($palabras[ $Arrayindex ] =~ /[a-zA-Z]/))) {
print $palabras[ $Arrayindex ], ' is at location ' , $Arrayindex , ' in the array' , "\n";
#join (" ", $palabras[ $Arrayindex ] , $palabras[ $Arrayindex + 1);
  } 
}
 
 =cut
 #bucle de comprobacion
 #foreach (@palabras) {
  #print "$_\n";
#}


=a
foreach my $ele (@palabras) 
{
 if (($ele =~ /[a-zA-Z]/) && ($ele =~ /[a-zA-Z]/)) {
 
   push @nombresa, $ele;
 }
  #print "$ele \n"; 
  #  print "$ele \n"; 
foreach (@palabras) {
  print "$_\n";
}
=cut

}
 close (FILE);
 
#Desconectar la base de datos
$dbh1->disconnect();

#=a
my $urldatosmet = 'https://ssl.smn.gob.ar/dpd/zipopendata.php?dato=datohorario';
my $historial = 'hist' . '.zip';
getstore( $urldatosmet, $historial );
#aqui se almacena el archivo
my $zip3 = Archive::Zip->new($historial);
foreach my $member ($zip3-> members)
{
    next if $member->isDirectory;
    (my $extractName = $member->fileName) =~ s{.*/}{};
    $member->extractToFileNamed(
      "$destinationDirectory/historial.txt");
}
#se extrae el archivo

#generamos nuestra base de datos, sus puertos, usuario, pw y nombre ya fueron creados
my $dbname2 = 'historial';
#nos conectamos y la preparamos para agregar los datos
my $dbh2 = DBI->connect("DBI:mysql:database=$dbname2;host=$dbhost", $dbuser, $dbpwd, {RaiseError => 1});
my $sth2 = $dbh2->prepare(
         "INSERT INTO `historial`(`fecha`, `hora`, `temp`, `hum`, `pnm`, `dd`, `ff`, `nombre`)
         VALUES (?,?,?,?,?,?,?,?)"
        #FECHA     HORA  TEMP   HUM   PNM    DD    FF     NOMBRE 
         );

 #vamos a leer linea a linea el archivo original y el nuevo
 my $linea2;
#abrimos y quitamos de en medio todo lo que no nos sirve del mismo escribiendo un nuevo archivo
open (OUT, '>C:\Users\Juan Nahuel Hidalgo\Desktop\Gral\paradigmas\2dotp\txt\historial2.txt') || die "Can't open this shit1";
open (FILE, 'C:\Users\Juan Nahuel Hidalgo\Desktop\Gral\paradigmas\2dotp\txt\historial.txt') || die "Can't open this shit2";
while ($linea2= <FILE>) {
  chomp($linea2);
  
 
#quitamos distintas cosas molestas (esto puede ser mejorado pero no encontre la forma)
$linea2 =~ s/FECHA     HORA  TEMP   HUM   PNM    DD    FF     NOMBRE                                             //g;
$linea2 =~ s/          //g;
$linea2 =~ s/[\[\]]//g;
my $o = "HOA  ºC   %  hPa  gr km/hr    ";
$linea2 =~ s/$o//g;

 
  #print $linea2;
  print OUT $linea2;
}
 close (FILE);
 close (OUT);
 
 #Abrimos el archivo ya procesado para parsear
open (FILE, 'C:\Users\Juan Nahuel Hidalgo\Desktop\Gral\paradigmas\2dotp\txt\historial2.txt') || die "Can't open this shit";
while ($linea= <FILE>) {
  chomp($linea);
 #$linea =~ s/\n//g; 
 #llenaremos un array con cada conjunto de caracteres separados por un espacio
 my @palabras2 = split(/\s+/, $linea);
 
 #se elimina el primer espacio en blanco ya que eliminarlo por expresion regular es mas costoso a nivel de proceso.
#shift(@palabras2);


   # for my $i (0 .. $#palabras2)
#{
 #     if (not ($palabras2[ $i ] =~ /[0-9]/)) {
  #       print $palabras2[$i], ' is at location ' , $i , ' in the array' , "\n";
   #   }
#}
}
 close (FILE);
$dbh2->disconnect();
#aqui se busca el nombre del archivo viejo si existiera para eliminarlo
#$rootdir = 'C:\Users\Juan Nahuel Hidalgo\Desktop\Gral\paradigmas\2dotp\txt\historial.txt';
#unlink ($rootdir);

#en ppm esta la otra parte

#=cut
