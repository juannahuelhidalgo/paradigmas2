#!C:\Perl64\bin\perl.exe

#Por ahora descarga los archivos del servidor, los descomprime (sobreescribiendo lo que saca).
#Tambien se conecta a la bbdd (local) y coloca el primer dato de clima diario
#Queda lograr automatizarlo
#Falta clasificar 5dias e historial


use strict;
use warnings;
use strict;
use LWP::Simple;
use open qw( :encoding(latin1) :std ); # Make UTF-8 default encoding
use Archive::Zip qw( :ERROR_CODES :CONSTANTS );
use DBI;
use Switch;

#conocemos e imprimimos el dia corriente en cuestion
#esto servira para crear y eliminar los backup solicitados (con su respectivo nombre)
my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time);
$year += 1900;
$mon++;
print "$mday/$mon/$year $hour:$min:$sec\n";


#aqui se busca el nombre del archivo viejo si existiera
my $rootdir = 'C:\Users\Juan Nahuel Hidalgo\Desktop\Gral\paradigmas\2dotp\txt\infodiariac.txt';
unlink ($rootdir);


#aqui se almacena el archivo (no es necesario eliminar el viejo porque se sobreescribe)
my $urldiaria = 'https://ssl.smn.gob.ar/dpd/zipopendata.php?dato=tiepre';
my $archivodiario = 'diaria' . '.zip';
getstore( $urldiaria, $archivodiario );


#se extrae el archivo
my $zip = Archive::Zip->new($archivodiario);
my $destinationDirectory = 'C:\Users\Juan Nahuel Hidalgo\Desktop\Gral\paradigmas\2dotp\txt';
foreach my $member ($zip-> members)
{
    next if $member->isDirectory;
    (my $extractName = $member->fileName) =~ s{.*/}{};
    $member->extractToFileNamed(
      "$destinationDirectory/infodiaria.txt");   
}


#generamos nuestra base de datos con sus puertos, usuario, pw y nombre
 my $dbname3 = 'diario';
 my $dbhost = '127.0.0.1';
 my $dbuser = 'root';
 my $dbpwd = '';
 #nos conectamos y la preparamos para agregar los datos
 my $dbh3 = DBI->connect("DBI:mysql:database=$dbname3;host=$dbhost", $dbuser, $dbpwd, {RaiseError => 1});
 my $sth3 = $dbh3->prepare(
         "INSERT INTO `diario`(`nombre`, fecha, hora, tiempo, visibilidad, n1, n2, n3, direccion, n4)
         VALUES (?,?,?,?,?,?,?,?,?,?)"
         );
 
#se extrae lo que se busca del archivo
#reemplazo "/" en el fichero ya que es innecesario gracias al ciclo for


#abrimos y parseamos el archivo
open (FILE, 'C:\Users\Juan Nahuel Hidalgo\Desktop\Gral\paradigmas\2dotp\txt\infodiaria.txt') || die "Can't open this shit";; 
while (<FILE>) {
  chomp;

  
  my $namediario;
  my $fechamal;
  my $horamal;
  my $tiempo,
  my $visibilidad;
  my $n1;
  my $n2;
  my $direccion;
  my $n3;
  my $n4;
  ($namediario, $fechamal, $horamal, $tiempo, $visibilidad, $n1, $n2, $n3, $direccion, $n4) = split(";");
   

 #puede ser sustituido por la linea del else todo el switch pero dejaria de ser parseo 100%
 my @fecha; 
 @fecha = split(/-/,$fechamal);
 switch($fecha[1]) {
    case ("enero")            { $fecha[1] = 1;}
    case ("febrero")          { $fecha[1] = 2; }
    case ("marzo")          {$fecha[1] = 3; }
    case ("abril")          { $fecha[1] = 4; }
    case ("mayo")          {$fecha[1] = 5; }
    case ("junio")          { $fecha[1] = 6; }
    case ("julio")          { $fecha[1] = 7; }
    case ("agosto")          { $fecha[1] = 8;  }
    case ("septiembre")          { $fecha[1] = 9; }
    case ("octubre")          { $fecha[1] = 10; }
    case ("noviembre")          { $fecha[1] = 11; }
    case ("diciembre")          { $fecha[1] = 12; }
    else              { $fecha[1] = $mon;  }
}
my $fechabien = "$fecha[2]/$fecha[1]/$fecha[0]";


my @horas; 
@horas = split(/:/,$horamal);
my $horabien = "$horas[0]:$horas[1]:$horas[1]";


#el siguiente comando introduce el valor a la bbdd en el orden de preparado
$sth3->execute($namediario, $fechabien, $horabien, $tiempo, $visibilidad, $n1, $n2, $n3, $direccion, $n4);
}
 close (FILE);
 

# Desconectar la base de datos
  if (! $dbh3->disconnect) {
     warn "Error al desconectarse de la base de datos: $DBI::errstr";
  }
  

 

my $url5dias = 'https://ssl.smn.gob.ar/dpd/zipopendata.php?dato=pron5d ';
my $cincodias = '5d' . '.zip';
getstore( $url5dias, $cincodias );
#aqui se almacena el archivo
my $zip2 = Archive::Zip->new($cincodias);
foreach my $member ($zip2-> members)
{
    next if $member->isDirectory;
    (my $extractName = $member->fileName) =~ s{.*/}{};
    $member->extractToFileNamed(
      "$destinationDirectory/cincodias.txt");
}
#se extrae el archivo

      
my $urldatosmet = 'https://ssl.smn.gob.ar/dpd/zipopendata.php?dato=datohorario';
my $historial = 'hist' . '.zip';
getstore( $urldatosmet, $historial );
#aqui se almacena el archivo
my $zip3 = Archive::Zip->new($historial);
foreach my $member ($zip3-> members)
{
    next if $member->isDirectory;
    (my $extractName = $member->fileName) =~ s{.*/}{};
    $member->extractToFileNamed(
      "$destinationDirectory/historial.txt");
}
#se extrae el archivo


#generamos nuestra base de datos con sus puertos, usuario, pw y nombre
 my $dbname1 = 'cincodias';
 my $dbname2 = 'historial';


#nos conectamos y la preparamos para agregar los datos
my $dbh1 = DBI->connect("DBI:mysql:database=$dbname1;host=$dbhost", $dbuser, $dbpwd, {RaiseError => 1});
my $sth1 = $dbh1->prepare(
         "INSERT INTO `cincodias`(`id`, `nombre`)
         VALUES (?,?)"
         );
my $dbh2 = DBI->connect("DBI:mysql:database=$dbname2;host=$dbhost", $dbuser, $dbpwd, {RaiseError => 1});


#el siguiente comando introduce el valor a la bbdd en el orden de preparado
#$sth1->execute( 1, "hola");


  #Desconectar la base de datos
  if (! $dbh1->disconnect) {
     warn "Error al desconectarse de la base de datos: $DBI::errstr";
  }
  # Desconectar la base de datos
  if (! $dbh2->disconnect) {
     warn "Error al desconectarse de la base de datos: $DBI::errstr";
  }
